---
layout: post
title: 快速排序及其优化
tags: 纸上得来终觉浅
math: true
date: 2021-05-06 15:32 +0800
---



## 快速排序的一般代码
```cpp
void Quick_Sort(int *arr, int begin, int end){
    if(begin > end)
        return;
    int tmp = arr[begin];
    int i = begin;
    int j = end;
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(j > i){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[begin] = arr[i];
    arr[i] = tmp;
    Quick_Sort(arr, begin, i-1);
    Quick_Sort(arr, i+1, end);
}
```

## 为什么说，快速排序是对冒泡排序的优化?

　　冒泡排序也涉及对元素的移动，但是那样移动起来很累。比如把最后一个元素移动到第 1 个，就需要比较 n-1 次，同时交换 n-1 次，效率很低。其实，只需把第 1 个元素和最后一个元素交换就好了，这种思想是不是在排序时可以借鉴呢？快速排序就是对冒泡排序的一个改进，就是这个原因。

　　快速排序是在冒泡排序的基础上改进而来的，冒泡排序每次只能交换相邻的两个元素，而快速排序是跳跃式的交换，交换的距离很大，因此总的比较和交换次数少了很多，速度也快了不少。
快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。

快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的

## 一定要从后往前访问?

在两个哨兵相遇的时候，一定能保证相遇到数是小于基准的（因为接下的要交换基准和这个哨兵的元素），所以只能从右边开始。如果基准值就选右边的，就需要从左边的开始扫描。
因此任何时间所以，必须从基准数的对面开始扫描。

## 时间复杂度分析
快速排序的时间性能取决于快速排序递归的深度，可以用递归树来描述递归算法的执行情况。
在最优情况下，Partition每次都划分得很均匀，如果排序n个关键字，其递归树的深度就为.log2n.+1，即仅需递归log2n次，需要时间为T（n）的话，第一次Partiation应该是需要对整个数组扫描一遍，做n次比较。然后，获得的枢轴将数组一分为二，那么各自还需要T（n/2）的时间（注意是最好情况，所以平分两半）
也就是说，在最优的情况下，快速排序算法的时间复杂度为O(nlogn)。


在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，它就是一棵斜树。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，最终其时间复杂度为O(n2)。（退化成冒泡排序）
参考链接：
https://blog.csdn.net/weshjiness/article/details/8660583

## 快速排序的优化（避免最坏情况）

对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。

最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列。

为了避免快速排序退化成冒泡排序，可以用以下两种选择基准的方式：


１,随机选取基准
引入的原因：在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴

```cpp
int SelectPivotRandom(int arr[],int low,int high)
{
	//产生枢轴的位置
	srand((unsigned)time(NULL));
	int pivotPos = rand()%(high - low) + low;
 
	//把枢轴位置的元素和low位置元素互换，此时可以和普通的快排一样调用划分函数
	swap(arr[pivotPos],arr[low]);
	return arr[low];
}
```
选取好了随机基准与原始列表中的第一个元素进行交换，然后整个排序算法的逻辑依然按照原先的方法进行。


2, 三数取中（median-of-three）

引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取枢轴

分析：最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约14%的比较次数

举例：待排序序列为：8 1 4 9 6 3 5 2 7 0

左边为：8，右边为0，中间为6.

这里取三个数排序后，中间那个数作为枢轴，则枢轴为6


## 需要注意的几个点（只针对本人）
1,每次排序会经历多次交换
2.可以每次都都与基准交换，也可以每次(两while循环)找到符合条件的元素跟基准交换
http://data.biancheng.net/view/117.html
3.最差的情况，每次划分有一边是空的


