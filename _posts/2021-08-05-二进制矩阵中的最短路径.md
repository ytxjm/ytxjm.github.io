---
layout: post
title: 二进制矩阵中的最短路径（力扣第1091题）
tags: 纸上得来终觉浅
math: true
date: 2021-05-11 13:00 +0800
---




## 题解：
```cpp
int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        if(grid.size()==0)
            return -1;
        if(grid[0][0] == 1) 
            return -1;
        int n = grid.size();
        std::queue<std::vector<int> > queue;//当前遍历到的为0的结点
        queue.push({0,0});
        std::vector<std::vector<int>> directions = //八个方向
            {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}};
        int step = 1;
        while(!queue.empty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){对每一层进行寻找 ，广度优先找最短路径的的常用方法
                std::vector<int> cur = queue.front();
                queue.pop();
                if(cur[0] == n-1 && cur[1] == n-1) 
                    return step;
                for(std::vector<int> d : directions){
                    int x = cur[0] + d[0];
                    int y = cur[1] + d[1];
                    if(x<0 || x>=n || y<0 || y>=n || grid[x][y]==1) 
                        continue;
                    queue.push({x,y});
                    grid[x][y] = 1;
                }
            }
            step++;
        }
        return -1;
    }
```





---

 以上
