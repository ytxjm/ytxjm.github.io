---
layout: post
title: C++中两种参数传递方式:值传递和传指针
tags: C++
math: true
date: 2017-06-19 15:32 +0800
---

## 老生常谈:

值传递和传指针是c++中老生常谈的问题，新人必须要掌握的东西无论是在实际的开发过程中还是面试中都会经常用到。今天花一点时间 ，结合自己在工作中遇到的实际例子再次总结一下。
首先来看一个经典的例子：

```c++
void GetMemory(char *p)
{ 
  p=(char *)malloc(100); 
} 
void Test(void)
{ 
  char *str=null; 
  GetMemory(str);
  strcpy(str, "Hello World!");
  printf("%s\n", str);
}
```
这是一个经典的面试题目，当你拿到这个题目后，面试官一般会问，这个程序有没有问题？能不能正确输出Hello World？

记得我第一次被问这个问题的时候，我的回答是不能！面试官问我为什么，我说：如果可能正确输出，你就不会问这个问题了。。哈哈

## 总结：
这个题目实际上就是一个值传递和传指针的问题，函数GetMemory用了一个指针做为参数，让人误以为是传指针...传指针不是说传的参数是指针就ok了，而关键是要看指针传进去后做了什么打操作！

**自己的理解:如果在函数中改变的是指针指向的内容，则是名符其实的传指针！**

这在上面的GetMemory中显然没有改变指针指向的内容，它在函数里新分配了一块内存，然后赋值给p，这样修改的是指针的值，而不是指针指向的内容，函数中的p与传进来的指针是两个完全独立的指针，分别指向不同的内存，自然不会有任何效果。看似传指针实际上在值传递。
	
如果将函数改成这样就ok了:
```c++
void GetMemory2(char **p) 
{
 *p=(char*)malloc(100); 
}
void Test(void)
{ 
  char *str=null; 
  GetMemory2(＆str);
  strcpy(str, "Hello World!");
  printf("%s\n", str);
}
```

```
这个函数可以成功的原因是，传进来的是指向指针指针， 在GetMemory2中修改是确实是指针（*p）的值，但是这个*p是被(**p)指向的值，所以是修改了(**p)指向的内容，可以修改成功，这个地方有点绕，仔细想想就清楚了.
```






---
以上