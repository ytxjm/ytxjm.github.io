---
layout: post
title: C++ 中多线程之间消息传递和二进制数据拷备
tags: C++
math: true
date: 2017-06-19 15:32 +0800
---

```c++
int OnGetCommonData(eint nIPCID,eint8* pbPackBuf,eint nReqLen,eint8** ppReply,eint nMsgCode)
{
//    eint8* pbMsgData = NULL;
//    SensorData* psCmdStr = NULL;
//
//    psCmdStr = (SensorData*)pbReqStr;
//    pbMsgData = (eint8*)malloc(nReqLen);//alloc memory space to store request data
//    memset(pbMsgData,0,nReqLen);
//    memcpy(pbMsgData,pbReqStr,nReqLen);|||||||| IPCBaseStr中的时间戳和优先级字节不对齐,所以不可以强转取数据,只能MemM_GetDataFromMem

    eint nPos=0;
    euint32 ulCmdCode=0;
    IPCBaseStr sCmdStr;
    nPos = MemM_GetDataFromMem(pbPackBuf,&ulCmdCode,sizeof(euint32),0);
    nPos = MemM_GetDataFromMem(pbPackBuf,&sCmdStr.unPriority,sizeof(euint32),nPos);
    nPos = MemM_GetDataFromMem(pbPackBuf,&sCmdStr.dTimeStamp,sizeof(edouble),nPos);//获得时间和优先级,只发单个的变量,不需要在堆中生成内存
    
    eint8* pbMsgData = NULL;
    pbMsgData = (eint8*)malloc(nReqLen);//alloc memory space to store request data
    memset(pbMsgData,0,nReqLen);
    memcpy(pbMsgData,pbPackBuf,nReqLen);//多线程,发送之间要malloc内存,发送堆中的数据
    //post message to laicontrol to process
    m_piMsgCtrl->PostMessage((CEMsgReceiver*)m_pMsgRecv,
                            HaiPriSensor+sCmdStr.unPriority,
                            sCmdStr.dTimeStamp,
                            nMsgCode,
                            (eint)pbMsgData,
                            nReqLen);
    
    return ERR_NONE;
}
```
二进制数据拷备:
数据在进程之间是以二进制数的形式传输的,即进程间通讯IPC是用二进制数传递的;
通过IPC传输的结构体数据不能用结构体强制类型转换获取其中的数据;
这是因为结构体数据有字节对齐,而二进制数数据没有;

如果一定用强制类型转换要非常小心,只有字节对齐的情况才可以获得正确的数据;
```c++
typedef struct _ipc_base_struct{
    euint32 unPriority;
    edouble dTimeStamp;
}IPCBaseStr;
```
如上面的结构体中,在64位机中euint32是4个字节,edouble是8个字节,字节没有对齐;
结构体的长度是16,二进制数据包的长度是12...一取就错!


多线程:

 同一进程下的两个线程共用一块堆;
不同的线程之间传递的变量,必须是在堆中生成的,即new或malloc的内存内容;
如果只发单个变量,可用临时变量;
